//JS-Заметки

1. Авто-тестирование с помощью фреймворка Mocha

	Авто-тесты нужны для тестирования отдельных значнений наших фунцкий, не отходя от кассы.

1.1 Behavior Driven Development(BDD)

	!BDD – это три в одном: и тесты, и документация, и примеры использования!

1.2 Основные блоки тестирования
	
	1) describe("Описание", функция)

	Описывает и располгает в себе отдельный блок теста.

	2) it("описание", функция)

	Этот блок уже располагает в себе сам тест.

1.3 Некоторые функции из библиотеки Chai

	assert.equal - сравнивает числа и выводит равны они или нет
	assert.isNaN - проверяет на математические ошибки и возвращает NaN

1.4 Вложенность describe и некоторые особенности

	Блок describe может хранить в себе другой describe, прямо как функция.

1.5 Пример прогаммы с использованием фреймворка Mocha

//сам скрипт

function pow(x, n) {
	if(n < 0) return NaN;
	if(n % 1 != 0) return NaN;

	let result = 1;

	for (let i = 0; i < n; i++) {
		result *= x;
	}

	return result;
} 


//test.js 
	describe("pow", function() {

	describe("Возводит x в степень 3", function() {

		function makeTest(x) {
			let expected = Math.pow(x, 3) ;
			it(`${x} в степени 4 будет ${expected}`, function() {
				assert.equal(pow(x, 3), expected);
			});
		}

		for (let x = 1; x <= 5; x++) {
			makeTest(x);
		}

	});

	//Далее есть возможность воспроизводить отдельные проверки.
	it("для отрицательных n возвращет NaN", function() {
		assert.isNaN(pow(2, -1));
	});

	it("для дробных n возвращает NaN", function() {
		assert.isNaN(pow(2, 1.5));
	});

});

2 Объекты

2.1 Определение

	Объект - тип данных хранящий в себе коллекцию элементов(чисел, строк и тд). Объявляется так: let user = new Object(), или так: let user = {}.
	Объекты имею свои ключи, которые указывают на элементы объекта(своего индексы в массиве)

2.2 Литералы и свойства

	Объявление типа: let user = {}, называется литеральная нотация или литерал объекта. Чтобы обратится к свойству объекта нужно, написать имя объекта и его ключ через точку.

	delete object.key - удаление свойства объекта

	!Notice!: объект типа const может быть изменен, т. е. не сам объект, а его свойства.

2.3 Вычисляемые свойства
	
	Мы можем создавать вычисляемые свойства с использованием квадратных скобок: 

	let fruit = prompt("Какой фрукт купить?", "apple");

	let bag = {
	  [fruit]: 5, // имя свойства будет взято из переменной fruit
	};

	alert(bag.apple); // выведет 5, если fruit = "apple" 

	То есть, мы называем ключ объекта с помощью переменной.

2.4 Проверка на существование свойства

	Существует 2 способа проверки. Первый через оператор ===, второй через оператор in. Примеры

	1)
	let user = {};
	alert( user.noDoesntMatter === undefined ); //true, т.е. нет

	2)
	let user = {};
	alert( "key" in user ); //false

2.5 Цикл for...in

	Данный цикл предназначен для перебора объекта. Синтаксис: 
	for(let key in object) { ... }

	!Note!: Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания. Но это можно обойти предписав "+" вначало ключа.

2.6 This

	This определятся тем, в каком контексте вы находитесь. Контекст - окружение, например, функция.

	This имеет смысл лишь в момент вызова метода. [ this.method() ]

	Таким образом, значение this передаётся правильно, только если функция вызывается напрямую с использованием синтаксиса точки obj.method()

	!Note!: Контекст имеет смысл только внутри функций.

2.7 Конструкторы, создание объектов

	Объект можно создать не только используя литеральное выражение( obj = {...} ), но и при помощи оператора new.

	Конструкторы - функции, позволяющие гибко заполнить объект. Т. е. мы создаем функцию, наполняем ее некоторыми свойствами, для нашего будущего объекта, и далее вызываем и присваем функцию объекту.

	Конструкторы могут передавать не только простые свойства, но и методы.

	До вызова конструктора (при помощи new) this - пустой, после он заполняется значениями.

	!Note!: Конструкторы стоит называть с большой буквы: function User() {...}

2.8 Тип данных symbol

	«Символ» представляет собой уникальный идентификатор.

	// Создаём символ id с описанием (именем) "id"
	let id = Symbol("id");

	Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.

	Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.

	К символу сложно случайно обратится, по этому именно он используется для идентификации объектов.

3 Типы данных

3.1 Числа. Методы для чисел

	num.toString(base) - вовзращает строковое предствление числа num в систему счисления base.

	Округления:

	1) Math.floor - округляет в меньшую сторону
	2) Math.ceil - округляет в большую сторону
	3) Math.round - округляет по правилам математики
	4) Math.toFixed(n) - округляет число до n знаков по правилам математики
	5) isFinite - проверяет число на тип number
	6) isNaN - проверят равна ли переменная NaN
	7) Object.is(num, num2) - сравнивает значения.
	8) parseInt parseFloat - преобразуют значение в число (если оно им является). 
		alert( parseInt('100px') ); // 100
		alert( parseFloat('12.5em') ); // 12.5

	Неточные вычисления.

	/.Внутри JavaScript число представлено в виде 64-битного формата IEEE-754. Для хранения числа используется 64 бита: 52 из них используется для хранения цифр, 11 из них для хранения положения десятичной точки (если число целое, то хранится 0), и один бит отведён на хранение знака./

	Часто не целые числа вычисляются не правильно (не точно). Например: alert( 0.1 + 0.2 ); // 0.30000000000000004
	Это можно исправить двумя способами, при помощи toFixed, и можно число временно умножить на 10 (или на больше), чтобы привести его к целому, выполнить мат действия, а после разделить обратно.
	alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3 а не 0.30000000000000004

3.2 Строки. Методы для подстрок

	Методы проверки:

	1) str.indexOf(target, startPos) - проверяет на наличие target в str и возрващает ее позицию (startPos - с какой позиции начинать поиск);

	2) str.includes(target, startPos) - возвращает true если target находится в str;

	3) str.startsWith и .endsWith - проверяют, начинается ли и заканчивается cтрока определенной строкой;

	4) str.slice(startPos, endPos) - 'вырезает' подстроку, начиная с позиции startPos и заканчивая endPos;

	Методы для сравнения подстрок:

	1) str.codePointAt(pos) - возвращает код символа находящегося на pos
	2) str.fromCodePoint(code) - создает символ по его коду code
	3) str.localeComprare(str2) - возвращает -1 если str < str2; 1 если str > str2; 0 если они равны.

3.3 Массивы. Методы массивов

	Массив - упорядоченная коллекция данных. 

Методы pop/push, shift/unshift

	Массив применяется в двух вариантах работы, в первом варианте, как очередь, во втором как "стек". Очередь работает так: все элементы стоят упорядочено, и начинается все с первого элемента, а заканчивается поздним, то есть первым пришел, первым и вышел (как очередь в магазине, например). Стек же наоборот, последним пришел, последним и вышел, т. е., как колода карт, последняя карта всегда сверху и ее всегда будут брать первой. 

	Методы удаления и добавления элеметов массива, работающие с концом массива.
	pop() - удаляет последний элемент массива и возвращает его (стек)
	push() - добавляет в конец массива элемент (очередь и стек)

	Методы, работающие с началом массива
	shift() - удаляет первый элемент массива, сдвигая очередь.
	unshift() - добавляет элемент в начало, сдвигая очередь.

	!Note!: массивом стоит пользоваться только в виде структуры с упорядоченными данными.

Особенности length

	length, в первую очередь, это не длина массива, а его последний индекс плюс один, т. е., если
	let arr = [];
	arr[25] = 5;
	то: arr.length// 26

	Таким образом, при помощи length можно перезаписать и, например, очистить массим: arr.length = 0;

Многомерные массивы

	В массиве могут хранится элементы, являющиеся массивами: 

	let matrix = [
		[1, 2, 3],
		[4, 5, 6],
		[7, 8, 9]
	];

	alert( matrix[1][1] ); // 5, центральный элемент

3.4 Методы массивов

Иные методы добавления/удаления элементов

	1)arr.splice(index[, deleteCount, elem1, ..., elemN) - начиная с позиции index удаляет deleteCount количество элементов, и заменяет (если это задано) на элемент/ты elem.

	2)arr.slice(startIndex, endIndex) - удаляет и возвращает элементы массива, начиная с startIndex, заканчива endIndex, соответсвенно.

	3)arr.concat(arg1, arg2, ...) - создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.

Поиск в массиве

	1) find - позволяет найти элементы из массива объектов. Возвращает true или false. findIndex - делает тоже самое, но возвращает индекс или -1 если не найдено
		arr.find(function(item, index, array) { ... });
	2) filter - может возрващать уже несколько объектов.

Преобразования массива

	1) arr.map - позволяет преобразовать текущий массив с помощью поочередного перебора его элементов. Перебирает схожим способом с методом forEach

	2) arr.sort - сортирует элементы массива и возрващает массив с элементами, рассположенными в порядке возрастания. При сравнении элементов, они преобразуются в строки, поэтому, если мы сравниваем числа, нам нужно добавить одну функцию для правильной сортировки:

	function check(a, b) {
		if (a > b) return 1;
		if (a === b) return 0;
		if (a < b) return -1;
	}

	let number = [6, 22, 1];

	console.log(number.sort(check));

	3) str.split(s) - преобразует строку в массив, разделенный аргументом s (и удаляя его, соответственно). Т. е. есть строка str = "Маша, Вася, Петя", при вызове метода str.split(", "), он возвратит массив с элементами [Маша, Вася, Петя], без запятых.

	4) arr.join(glue) - делает все ровно наоборот.

reduce/reduceRight

	reduce перебирает массив и считает сумму его элементов. Или преобразует все элементы в единую кучу. Выглядит так: 

	let value = arr.reduce(function(prevVal, item, index, array) {...}, [initial])

	В начале алгоритма prevVal равен initial (т. е. стартует с заданного значения initial). С последующим выполнением оно уже изменяется по ходу функции.

	reduceRight работает аналогично, но выполнение происходит справа налево.